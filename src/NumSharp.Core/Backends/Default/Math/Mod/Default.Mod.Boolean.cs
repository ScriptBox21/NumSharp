//Generated by Regex Templating Engine at 25/04/2021 17:12:59 UTC
//template source: K:\code\SciSharp\NumSharp\src\NumSharp.Core\Backends\Default\Math\Templates\Default.Op.General.template.cs

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using NumSharp.Backends.Unmanaged;
using NumSharp.Utilities;
using NumSharp.Utilities.Maths;

namespace NumSharp.Backends
{
    //v2
    public partial class DefaultEngine
    {
        [MethodImpl((MethodImplOptions)768)]
        [SuppressMessage("ReSharper", "JoinDeclarationAndInitializer")]
        [SuppressMessage("ReSharper", "CompareOfFloatsByEqualityOperator")]
        public unsafe NDArray ModBoolean(in NDArray lhs, in NDArray rhs)
        {
            //lhs is NDArray of bool
            switch (rhs.GetTypeCode)
            {
#if _REGEN
                %op = "Mod"
                %op_bool = "*"
	            %foreach supported_dtypes, supported_dtypes_lowercase%
                case NPTypeCode.#1: {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.#(op)(*((bool*)lhs.Address), *((#2*)rhs.Address)), ret_type));
                    
                    (Shape leftshape, Shape rightshape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (bool*)lhs.Address;
                    var rhs_address = (#2*)rhs.Address;
                    var retShape = leftshape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !leftshape.IsBroadcasted && !leftshape.IsSliced;
                    var rightLinear = !rightshape.IsBroadcasted && !rightshape.IsSliced;
                    var len = ret.size;
                    switch (ret_type) {
                        %foreach supported_dtypes,supported_dtypes_lowercase%
                        |#normalcast = ("("+str("#102")+")")
                        |#caster = ( "#102"=="bool" | ("Converts.To" + str("#101")) | ("bool"=="bool"|("#2"=="bool"|("Converts.To" + str("#101"))|normalcast)| normalcast) )
	                    case NPTypeCode.#101: {
		                    var ret_address = (#102*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = #(caster)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = #(caster)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = #(caster)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = #(caster)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = #(caster)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = #(caster)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = #(caster)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = #(caster)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
                        %
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                %
                default:
		            throw new NotSupportedException();
#else

                case NPTypeCode.Boolean: {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Mod(*((bool*)lhs.Address), *((bool*)rhs.Address)), ret_type));
                    
                    (Shape leftshape, Shape rightshape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (bool*)lhs.Address;
                    var rhs_address = (bool*)rhs.Address;
                    var retShape = leftshape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !leftshape.IsBroadcasted && !leftshape.IsSliced;
                    var rightLinear = !rightshape.IsBroadcasted && !rightshape.IsSliced;
                    var len = ret.size;
                    switch (ret_type) {
	                    case NPTypeCode.Boolean: {
		                    var ret_address = (bool*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Byte: {
		                    var ret_address = (byte*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToByte(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToByte(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToByte(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToByte(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToByte(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToByte(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToByte(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToByte(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int16: {
		                    var ret_address = (short*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt16(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt16(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt16(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt16(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToInt16(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt16(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToInt16(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToInt16(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt16: {
		                    var ret_address = (ushort*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt16(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt16(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt16(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt16(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToUInt16(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt16(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToUInt16(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToUInt16(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int32: {
		                    var ret_address = (int*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt32(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt32(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt32(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt32(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToInt32(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt32(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToInt32(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToInt32(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt32: {
		                    var ret_address = (uint*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt32(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt32(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt32(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt32(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToUInt32(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt32(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToUInt32(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToUInt32(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int64: {
		                    var ret_address = (long*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt64(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt64(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt64(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt64(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToInt64(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToInt64(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToInt64(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToInt64(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt64: {
		                    var ret_address = (ulong*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt64(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt64(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt64(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt64(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToUInt64(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToUInt64(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToUInt64(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToUInt64(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Char: {
		                    var ret_address = (char*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToChar(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToChar(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToChar(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToChar(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToChar(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToChar(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToChar(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToChar(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Double: {
		                    var ret_address = (double*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToDouble(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToDouble(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToDouble(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToDouble(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToDouble(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToDouble(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToDouble(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToDouble(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Single: {
		                    var ret_address = (float*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToSingle(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToSingle(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToSingle(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToSingle(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToSingle(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToSingle(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToSingle(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToSingle(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Decimal: {
		                    var ret_address = (decimal*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToDecimal(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToDecimal(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToDecimal(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToDecimal(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToDecimal(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToDecimal(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToDecimal(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToDecimal(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Byte: {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Mod(*((bool*)lhs.Address), *((byte*)rhs.Address)), ret_type));
                    
                    (Shape leftshape, Shape rightshape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (bool*)lhs.Address;
                    var rhs_address = (byte*)rhs.Address;
                    var retShape = leftshape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !leftshape.IsBroadcasted && !leftshape.IsSliced;
                    var rightLinear = !rightshape.IsBroadcasted && !rightshape.IsSliced;
                    var len = ret.size;
                    switch (ret_type) {
	                    case NPTypeCode.Boolean: {
		                    var ret_address = (bool*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Byte: {
		                    var ret_address = (byte*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int16: {
		                    var ret_address = (short*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt16: {
		                    var ret_address = (ushort*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int32: {
		                    var ret_address = (int*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt32: {
		                    var ret_address = (uint*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int64: {
		                    var ret_address = (long*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt64: {
		                    var ret_address = (ulong*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Char: {
		                    var ret_address = (char*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Double: {
		                    var ret_address = (double*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Single: {
		                    var ret_address = (float*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Decimal: {
		                    var ret_address = (decimal*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Int16: {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Mod(*((bool*)lhs.Address), *((short*)rhs.Address)), ret_type));
                    
                    (Shape leftshape, Shape rightshape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (bool*)lhs.Address;
                    var rhs_address = (short*)rhs.Address;
                    var retShape = leftshape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !leftshape.IsBroadcasted && !leftshape.IsSliced;
                    var rightLinear = !rightshape.IsBroadcasted && !rightshape.IsSliced;
                    var len = ret.size;
                    switch (ret_type) {
	                    case NPTypeCode.Boolean: {
		                    var ret_address = (bool*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Byte: {
		                    var ret_address = (byte*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int16: {
		                    var ret_address = (short*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt16: {
		                    var ret_address = (ushort*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int32: {
		                    var ret_address = (int*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt32: {
		                    var ret_address = (uint*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int64: {
		                    var ret_address = (long*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt64: {
		                    var ret_address = (ulong*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Char: {
		                    var ret_address = (char*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Double: {
		                    var ret_address = (double*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Single: {
		                    var ret_address = (float*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Decimal: {
		                    var ret_address = (decimal*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.UInt16: {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Mod(*((bool*)lhs.Address), *((ushort*)rhs.Address)), ret_type));
                    
                    (Shape leftshape, Shape rightshape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (bool*)lhs.Address;
                    var rhs_address = (ushort*)rhs.Address;
                    var retShape = leftshape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !leftshape.IsBroadcasted && !leftshape.IsSliced;
                    var rightLinear = !rightshape.IsBroadcasted && !rightshape.IsSliced;
                    var len = ret.size;
                    switch (ret_type) {
	                    case NPTypeCode.Boolean: {
		                    var ret_address = (bool*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Byte: {
		                    var ret_address = (byte*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int16: {
		                    var ret_address = (short*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt16: {
		                    var ret_address = (ushort*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int32: {
		                    var ret_address = (int*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt32: {
		                    var ret_address = (uint*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int64: {
		                    var ret_address = (long*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt64: {
		                    var ret_address = (ulong*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Char: {
		                    var ret_address = (char*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Double: {
		                    var ret_address = (double*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Single: {
		                    var ret_address = (float*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Decimal: {
		                    var ret_address = (decimal*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Int32: {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Mod(*((bool*)lhs.Address), *((int*)rhs.Address)), ret_type));
                    
                    (Shape leftshape, Shape rightshape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (bool*)lhs.Address;
                    var rhs_address = (int*)rhs.Address;
                    var retShape = leftshape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !leftshape.IsBroadcasted && !leftshape.IsSliced;
                    var rightLinear = !rightshape.IsBroadcasted && !rightshape.IsSliced;
                    var len = ret.size;
                    switch (ret_type) {
	                    case NPTypeCode.Boolean: {
		                    var ret_address = (bool*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Byte: {
		                    var ret_address = (byte*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int16: {
		                    var ret_address = (short*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt16: {
		                    var ret_address = (ushort*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int32: {
		                    var ret_address = (int*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt32: {
		                    var ret_address = (uint*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int64: {
		                    var ret_address = (long*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt64: {
		                    var ret_address = (ulong*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Char: {
		                    var ret_address = (char*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Double: {
		                    var ret_address = (double*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Single: {
		                    var ret_address = (float*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Decimal: {
		                    var ret_address = (decimal*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.UInt32: {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Mod(*((bool*)lhs.Address), *((uint*)rhs.Address)), ret_type));
                    
                    (Shape leftshape, Shape rightshape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (bool*)lhs.Address;
                    var rhs_address = (uint*)rhs.Address;
                    var retShape = leftshape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !leftshape.IsBroadcasted && !leftshape.IsSliced;
                    var rightLinear = !rightshape.IsBroadcasted && !rightshape.IsSliced;
                    var len = ret.size;
                    switch (ret_type) {
	                    case NPTypeCode.Boolean: {
		                    var ret_address = (bool*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Byte: {
		                    var ret_address = (byte*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int16: {
		                    var ret_address = (short*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt16: {
		                    var ret_address = (ushort*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int32: {
		                    var ret_address = (int*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt32: {
		                    var ret_address = (uint*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int64: {
		                    var ret_address = (long*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt64: {
		                    var ret_address = (ulong*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Char: {
		                    var ret_address = (char*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Double: {
		                    var ret_address = (double*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Single: {
		                    var ret_address = (float*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Decimal: {
		                    var ret_address = (decimal*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Int64: {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Mod(*((bool*)lhs.Address), *((long*)rhs.Address)), ret_type));
                    
                    (Shape leftshape, Shape rightshape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (bool*)lhs.Address;
                    var rhs_address = (long*)rhs.Address;
                    var retShape = leftshape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !leftshape.IsBroadcasted && !leftshape.IsSliced;
                    var rightLinear = !rightshape.IsBroadcasted && !rightshape.IsSliced;
                    var len = ret.size;
                    switch (ret_type) {
	                    case NPTypeCode.Boolean: {
		                    var ret_address = (bool*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Byte: {
		                    var ret_address = (byte*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int16: {
		                    var ret_address = (short*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt16: {
		                    var ret_address = (ushort*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int32: {
		                    var ret_address = (int*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt32: {
		                    var ret_address = (uint*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int64: {
		                    var ret_address = (long*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt64: {
		                    var ret_address = (ulong*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Char: {
		                    var ret_address = (char*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Double: {
		                    var ret_address = (double*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Single: {
		                    var ret_address = (float*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Decimal: {
		                    var ret_address = (decimal*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.UInt64: {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Mod(*((bool*)lhs.Address), *((ulong*)rhs.Address)), ret_type));
                    
                    (Shape leftshape, Shape rightshape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (bool*)lhs.Address;
                    var rhs_address = (ulong*)rhs.Address;
                    var retShape = leftshape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !leftshape.IsBroadcasted && !leftshape.IsSliced;
                    var rightLinear = !rightshape.IsBroadcasted && !rightshape.IsSliced;
                    var len = ret.size;
                    switch (ret_type) {
	                    case NPTypeCode.Boolean: {
		                    var ret_address = (bool*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Byte: {
		                    var ret_address = (byte*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int16: {
		                    var ret_address = (short*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt16: {
		                    var ret_address = (ushort*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int32: {
		                    var ret_address = (int*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt32: {
		                    var ret_address = (uint*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int64: {
		                    var ret_address = (long*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt64: {
		                    var ret_address = (ulong*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Char: {
		                    var ret_address = (char*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Double: {
		                    var ret_address = (double*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Single: {
		                    var ret_address = (float*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Decimal: {
		                    var ret_address = (decimal*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Char: {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Mod(*((bool*)lhs.Address), *((char*)rhs.Address)), ret_type));
                    
                    (Shape leftshape, Shape rightshape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (bool*)lhs.Address;
                    var rhs_address = (char*)rhs.Address;
                    var retShape = leftshape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !leftshape.IsBroadcasted && !leftshape.IsSliced;
                    var rightLinear = !rightshape.IsBroadcasted && !rightshape.IsSliced;
                    var len = ret.size;
                    switch (ret_type) {
	                    case NPTypeCode.Boolean: {
		                    var ret_address = (bool*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Byte: {
		                    var ret_address = (byte*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int16: {
		                    var ret_address = (short*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt16: {
		                    var ret_address = (ushort*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int32: {
		                    var ret_address = (int*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt32: {
		                    var ret_address = (uint*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int64: {
		                    var ret_address = (long*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt64: {
		                    var ret_address = (ulong*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Char: {
		                    var ret_address = (char*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Double: {
		                    var ret_address = (double*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Single: {
		                    var ret_address = (float*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Decimal: {
		                    var ret_address = (decimal*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Double: {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Mod(*((bool*)lhs.Address), *((double*)rhs.Address)), ret_type));
                    
                    (Shape leftshape, Shape rightshape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (bool*)lhs.Address;
                    var rhs_address = (double*)rhs.Address;
                    var retShape = leftshape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !leftshape.IsBroadcasted && !leftshape.IsSliced;
                    var rightLinear = !rightshape.IsBroadcasted && !rightshape.IsSliced;
                    var len = ret.size;
                    switch (ret_type) {
	                    case NPTypeCode.Boolean: {
		                    var ret_address = (bool*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Byte: {
		                    var ret_address = (byte*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int16: {
		                    var ret_address = (short*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt16: {
		                    var ret_address = (ushort*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int32: {
		                    var ret_address = (int*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt32: {
		                    var ret_address = (uint*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int64: {
		                    var ret_address = (long*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt64: {
		                    var ret_address = (ulong*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Char: {
		                    var ret_address = (char*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Double: {
		                    var ret_address = (double*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Single: {
		                    var ret_address = (float*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Decimal: {
		                    var ret_address = (decimal*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Single: {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Mod(*((bool*)lhs.Address), *((float*)rhs.Address)), ret_type));
                    
                    (Shape leftshape, Shape rightshape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (bool*)lhs.Address;
                    var rhs_address = (float*)rhs.Address;
                    var retShape = leftshape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !leftshape.IsBroadcasted && !leftshape.IsSliced;
                    var rightLinear = !rightshape.IsBroadcasted && !rightshape.IsSliced;
                    var len = ret.size;
                    switch (ret_type) {
	                    case NPTypeCode.Boolean: {
		                    var ret_address = (bool*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Byte: {
		                    var ret_address = (byte*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int16: {
		                    var ret_address = (short*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt16: {
		                    var ret_address = (ushort*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int32: {
		                    var ret_address = (int*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt32: {
		                    var ret_address = (uint*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int64: {
		                    var ret_address = (long*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt64: {
		                    var ret_address = (ulong*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Char: {
		                    var ret_address = (char*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Double: {
		                    var ret_address = (double*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Single: {
		                    var ret_address = (float*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Decimal: {
		                    var ret_address = (decimal*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                case NPTypeCode.Decimal: {
                    //if return type is scalar
                    var ret_type = np._FindCommonType(lhs, rhs);
                    if (lhs.Shape.IsScalar && rhs.Shape.IsScalar)
                        return NDArray.Scalar(Converts.ChangeType(Operator.Mod(*((bool*)lhs.Address), *((decimal*)rhs.Address)), ret_type));
                    
                    (Shape leftshape, Shape rightshape) = DefaultEngine.Broadcast(lhs.Shape, rhs.Shape);
                    var lhs_address = (bool*)lhs.Address;
                    var rhs_address = (decimal*)rhs.Address;
                    var retShape = leftshape.Clean();
                    var ret = new NDArray(ret_type, retShape, false);
                    var leftLinear = !leftshape.IsBroadcasted && !leftshape.IsSliced;
                    var rightLinear = !rightshape.IsBroadcasted && !rightshape.IsSliced;
                    var len = ret.size;
                    switch (ret_type) {
	                    case NPTypeCode.Boolean: {
		                    var ret_address = (bool*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = Converts.ToBoolean(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = Converts.ToBoolean(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Byte: {
		                    var ret_address = (byte*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (byte)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (byte)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int16: {
		                    var ret_address = (short*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (short)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (short)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt16: {
		                    var ret_address = (ushort*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ushort)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ushort)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int32: {
		                    var ret_address = (int*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (int)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (int)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt32: {
		                    var ret_address = (uint*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (uint)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (uint)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Int64: {
		                    var ret_address = (long*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (long)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (long)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.UInt64: {
		                    var ret_address = (ulong*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (ulong)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (ulong)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Char: {
		                    var ret_address = (char*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (char)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (char)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Double: {
		                    var ret_address = (double*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (double)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (double)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Single: {
		                    var ret_address = (float*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (float)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (float)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    case NPTypeCode.Decimal: {
		                    var ret_address = (decimal*) ret.Address;
                            
                            if (leftLinear && rightLinear) {
                                Debug.Assert(leftshape.size == len && rightshape.size == len);
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), (rhs_address[i])));
                                }

                                return ret;
                            } 

                            ValueCoordinatesIncrementor incr;
                            if (leftLinear) { // && !rightLinear
                                if (rightshape.IsBroadcasted && rightshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var rval = *rhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod((lhs_address[i]), rval));
                                } else {
                                    int leftOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftOffset++]), (rhs_address[rightshape.GetOffset(current)])));
                                    } while (incr.Next() != null);
                                }
                            } else if (rightLinear) { // !leftLinear && 
                                if (leftshape.IsBroadcasted && leftshape.BroadcastInfo.OriginalShape.IsScalar) {
                                    var lval = *lhs_address;
                                    for (int i = 0; i < len; i++) ret_address[i] = (decimal)(Operator.Mod(lval, (rhs_address[i])));
                                } else {
                                    int rightOffset = 0;
                                    int retOffset = 0;
                                    incr = new ValueCoordinatesIncrementor(ref retShape);
                                    int[] current = incr.Index;
                                    do {
                                        ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightOffset++])));
                                    } while (incr.Next() != null);
                                }
                            } else {
                                int retOffset = 0;
                                incr = new ValueCoordinatesIncrementor(ref retShape);
                                int[] current = incr.Index;
                                do {
                                    ret_address[retOffset++] = (decimal)(Operator.Mod((lhs_address[leftshape.GetOffset(current)]), (rhs_address[rightshape.GetOffset(current)])));
                                } while (incr.Next() != null);
                            }

                            return ret;
	                    }
	                    default:
		                    throw new NotSupportedException();
                    }
                }
                default:
		            throw new NotSupportedException();
#endif
            }
        }
    }
}
